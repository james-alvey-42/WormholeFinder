(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* Solver functions for the U(1) wormholes in the axion system within GR *)

(* Note that this code works in dimensionless variables A(\[Rho]), F(\[Rho]) *)
(* These are related to the variables in the companion paper via \[Rho] = r\[Sqrt](3Subscript[\[Lambda]M, P]^2/8\[Pi]), A = R\[Sqrt](3Subscript[\[Lambda]M, P]^2/8\[Pi]), F = f\[Sqrt](8\[Pi]/3Subscript[M, P]^2) *)

GeV = 1; (* Set up units *)
Mp = 1.220890 10^19 GeV; (* Define Planck constant *)
n = 1; (* Set value of global charge *)

(* Apply the initial conditions A(0), F(0) *)
BoundaryCondition[F0_, A0_, Fa_, Q_] := F0^2 A0^4 - (1/4 F0^2 A0^6 (F0^2 - Fa^2)^2 + Q);

(* For a given guess of F(0), compute the corresponding value of A(0) that satisfies the boundary conditions *)
InitSolver[F0_, \[Lambda]_, fa_]:=(
$Fa = fa \[Sqrt]((8\[Pi])/(3 Mp^2));
$Q = (n^2 \[Lambda]^2)/(8\[Pi]^4);
$Min = (2 $Q)^(1/6) (F0^4 (F0^2 - $Fa^2))^(-1/6);
sol = NSolve[BoundaryCondition[F0, A0, $Fa, $Q] == 0 && A0 < $Min && A0 > 0 , {A0}, WorkingPrecision->100];
A0 /. sol[[1]]
);

(* Solve for the differential equation evolution for a given F(0), A(0), P(0), \[Lambda], Subscript[f, a] *)
EvolutionSolver[F0_, A0_, \[Lambda]_, fa_] :=(
$Fa = fa \[Sqrt]((8\[Pi])/(3 Mp^2));
$Q = (n^2 \[Lambda]^2)/(8\[Pi]^4);

sol = NDSolve[{ 
A''[\[Rho]] == -A[\[Rho]](1/4 (F[\[Rho]]^2 - $Fa^2)^2 + F'[\[Rho]]^2 - (2 $Q)/(F[\[Rho]]^2 A[\[Rho]]^6)),
F''[\[Rho]] + 3 A'[\[Rho]]/A[\[Rho]] F'[\[Rho]] == F[\[Rho]](F[\[Rho]]^2 - $Fa^2) - (2 $Q)/(F[\[Rho]]^3 A[\[Rho]]^6),
A[0]== A0,
F[0]== F0,
A'[0] == 0,
F'[0] == 0
},
{A, F},
{\[Rho], 0, 10^9},
Method->{"StiffnessSwitching", Method->{"ExplicitRungeKutta", Automatic}},
{AccuracyGoal->23,PrecisionGoal->23, WorkingPrecision->100}];
Asol = A/. sol;
Fsol = F/. sol;
{Asol[[1]], Fsol[[1]]}
);
(* Access these solutions by calling Asol[#], Fsol[#], Psol[#] *)

(* Combine the initial conditions solver and the differential equation solver *)
FullSolver[F0_, \[Lambda]_, fa_]:=(
$Fa = fa \[Sqrt]((8\[Pi])/(3 Mp^2));
$Q = (n^2 \[Lambda]^2)/(8\[Pi]^4);
$A0 = InitSolver[F0, \[Lambda], fa];
solutions = EvolutionSolver[F0, $A0, \[Lambda], fa];
Asol = solutions[[1]];
Fsol = solutions[[2]];
);

(* Use a shooting method to find the solution that satisfies the boundary conditions at \[Rho] = \[Infinity] *)
(* Checks to see whether the derivative at the point where the numerical method breaks down is positive or negative and then applies bisection to the initial condition F(0) *)
(* Iterates this process nmax times *)
IterateSolver[\[Lambda]_, fa_, nmax_]:=(
F0min = 0.5;
F0max = 3.0;
Do[(
F0mid = 0.5(F0min + F0max);
FullSolver[F0mid, \[Lambda], fa] // Quiet;
Print["Run ", run, ": F(0) = ", NumberForm[F0mid,7], ", \!\(\*SubscriptBox[\(\[Rho]\), \(max\)]\) = ", NumberForm[Fsol[[1, 1]][[2]], 5]];
Quiet[
Fpend = Maximize[{Fsol'[\[Rho]p], 0.001 <= \[Rho]p <= Fsol[[1, 1]][[2]]}, {\[Rho]p}][[1]];
Apend = Maximize[{Asol'[\[Rho]p], 0.001 <= \[Rho]p <= Fsol[[1, 1]][[2]]}, {\[Rho]p}][[1]];
];
Print["F'(\!\(\*SubscriptBox[\(\[Rho]\), \(max\)]\)) = ", Fpend, ", A'(\!\(\*SubscriptBox[\(\[Rho]\), \(max\)]\)) = ", NumberForm[Apend, 5]];
If[Fpend > 0,
(F0max = F0mid;),
(F0min = F0mid;)];
),{run, 1, nmax}];
);

(* Plots current F(\[Rho]), A(\[Rho]), P(\[Rho]) and A'(\[Rho]) *)
MakePlot[]:=(
Quiet[
fp = LogLogPlot[{Fsol[\[Rho]p], $Fa \[Rho]p^0}, {\[Rho]p, 0.001, 2000}, Frame-> True, PlotRange-> {0.5 $Fa, 1.5 Fsol[0.001]}, PlotStyle->{{Purple, Thick}, {Black, Dashed}}, FrameLabel->{"\[Rho]", "F(\[Rho])"}];
ap = LogLogPlot[{Asol[\[Rho]p], \[Rho]p}, {\[Rho]p, 0.001, 2000}, Frame-> True, PlotRange-> {0.001, 2000},PlotStyle->{{Purple, Thick}, {Black, Dashed}}, FrameLabel->{"\[Rho]", "A(\[Rho])"}];
app = LogLinearPlot[{Asol'[\[Rho]p], \[Rho]p^0}, {\[Rho]p, 0.001, 2000}, Frame-> True, PlotRange->{0.0, 1.1}, PlotStyle->{{Purple, Thick}, {Black, Dashed}}, FrameLabel->{"\[Rho]", "A'(\[Rho])"}];
];
GraphicsGrid[{{fp}, {ap}, {app}}]
);

Print["Successfully loaded u1.m"];
